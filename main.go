/*
	             _____ _____ _____ _____ _____
				|   __|   __|   __|   __|  |  |
				|   __|   __|   __|__   |     |
				|__|  |_____|_____|_____|__|__|
				bitcoin mempool stats



	 NOTE: In order to have close to realtime mempool info bitcoin node should be patched.
	 By default getrawmempool by default returns unsorted list of transactions.
*/
package main

import (
	"context"
	"fmt"
	"log"
	"os"

	"github.com/1F47E/go-feesh/api"
	"github.com/1F47E/go-feesh/client"
	"github.com/1F47E/go-feesh/config"
	"github.com/1F47E/go-feesh/core"
	mblock "github.com/1F47E/go-feesh/entity/models/block"
	"github.com/1F47E/go-feesh/logger"
	"github.com/1F47E/go-feesh/notificator"
	smap "github.com/1F47E/go-feesh/storage/map"

	// docs are generated by Swag CLI
	_ "github.com/1F47E/go-feesh/docs"
)

const banner = `
            _____ _____ _____ _____ _____ 
           |   __|   __|   __|   __|  |  |
           |   __|   __|   __|__   |     |
           |__|  |_____|_____|_____|__|__|
           bitcoin mempool stats

`

// global vars to be filled via build args and later used in api
var version string
var buildTime string

var cli *client.Client

// @title Feesh API
// @version 0.0.1
// @description API for feeding the feesh some data
// @host localhost:8080
// @BasePath /v1
// @schemes https
func main() {
	fmt.Print(banner)
	fmt.Println()

	// set env with version (from binary)
	os.Setenv("BUILD_VERSION", version)
	os.Setenv("BUILD_TIME", buildTime)
	logger.Log.Infof("===== Starting app. Version: %s, Build time: %s", version, buildTime)

	var err error
	cfg := config.NewConfig()

	if os.Getenv("DRY") != "1" {

		// create RPC client
		cli, err = client.NewClient(cfg.RpcHost, cfg.RpcUser, cfg.RpcPass)
		if err != nil {
			log.Fatalln("error creating client:", err)
		}

		// get node info
		info, err := cli.GetInfo()
		if err != nil {
			log.Fatalln("error on getinfo:", err)
		}
		log.Printf("node info: %+v\n", info)

		// get last block hash
		bestBlock, err := cli.GetBestBlock()
		if err != nil {
			log.Fatalln("error on getbestblock:", err)
		}
		log.Println("last block hash:", bestBlock.Hash)

		b, err := cli.GetBlock(bestBlock.Hash)
		if err != nil {
			log.Fatalln("error on getblock:", err)
		}
		log.Println("block tx cnt:", len(b.Transactions))

		// parse block tx, calc value and fee
		// txs := make([]*txpool.TxPool, len(b.Transactions))
		var totalValue, totalFee uint64
		// for _, txid := range b.Transactions {
		// in, out := getTxAmounts(txid)
		// tx := &mtx.Tx{
		// 	Hash:      txid,
		// 	AmountIn:  in,
		// 	AmountOut: out,
		// }
		// totalValue += in
		// totalFee += tx.Fee()
		// txs[i] = tx
		// }
		wBlock := &mblock.Block{
			Hash:   b.Hash,
			Height: b.Height,
			Value:  totalValue,
			Fee:    totalFee,
		}
		log.Printf("block %d, value: %d, fee: %d\n", wBlock.Height, wBlock.Value, wBlock.Fee)
	}

	// get block header
	// header, err := cli.GetBlockHeader(bestBlock.Hash)
	// if err != nil {
	// 	log.Fatalln("error on getblockheader:", err)
	// }
	// log.Println("prev block hash:", header.Previousblockhash)
	// // get full block data (tx list)
	// b, err := cli.GetBlock(bestBlock.Hash)
	// if err != nil {
	// 	log.Fatalln("error on getblock:", err)
	// }
	// log.Println("block tx cnt:", len(b.Transactions))

	// TODO: graceful shutdown
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	// create storage

	// create in mem storage (debug only)
	strg := smap.New()
	// create redis storage
	// s, err := sredis.New(ctx)
	// if err != nil {
	// 	log.Fatalln("error on redis storage:", err)
	// }

	// common channel for WS notifications
	broadcastCh := make(chan notificator.Msg)

	// WS notificator
	noficator := notificator.New(broadcastCh)

	// create core with RPC client and storage
	c := core.NewCore(ctx, cfg, cli, strg, broadcastCh)

	// create API with WS
	a := api.NewApi(c, noficator)

	// start main workers
	c.Start()

	// start server
	err = a.Listen()
	if err != nil {
		log.Fatalf("error on listen: %v", err)
	}
}
